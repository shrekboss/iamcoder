## 线程池：业务代码最常用也最容易犯错的组件

### 线程池的声明需要手动进行

- 翻看 newFixedThreadPool 方法的源码不难发现，线程池的工作队列直接 new 了一个 LinkedBlockingQueue，而默认构造方法的
  LinkedBlockingQueue 是一个 Integer.MAX_VALUE 长度的队列，可以认为是无界的
- 翻看 newCachedThreadPool 的源码可以看到，这种线程池的最大线程数是 Integer.MAX_VALUE，可以认为是没有上限的，而其工作队列
  SynchronousQueue 是一个没有存储空间的阻塞队列，它的核心线程数是 0，而 keepAliveTime 是 60 秒
- 同样不建议使用 Executors 提供的两种快捷的线程池，原因如下：
    - 需要根据自己的场景、并发情况来评估线程池的几个核心参数，包括核心线程数、最大线程数、线程回收策略、工作队列的类型，以及拒绝策略，确保线程池的工作行为符合需求，一般都需要设置有界的工作队列和可控的线程数。
    - 任何时候，都应该为自定义线程池指定有意义的名称，以方便排查问题。当出现线程数量暴增、线程死锁、线程占用大量
      CPU、线程执行出现异常等问题时，我们往往会抓取线程栈。此时，有意义的线程名称，就可以方便我们定位问题。
- 用一些监控手段来观察线程池的状态

参考代码：[threadpooloom](threadpooloom)

### 线程池线程管理策略详解

总结出线程池默认的工作行为：

- 不会初始化 corePoolSize 个线程，有任务来了才创建工作线程；
- 当核心线程满了之后不会立即扩容线程池，而是把任务堆积到工作队列中；
- 当工作队列满了后扩容线程池，一直到线程个数达到 maximumPoolSize 为止；
- 如果队列已满且达到了最大线程后还有任务进来，按照拒绝策略处理；
- 当线程数大于核心线程数时，线程等待 keepAliveTime 后还是没有任务需要处理的话，收缩线程到核心线程数。

可以通过一些手段来改变这些默认工作行为：

- 声明线程池后立即调用 prestartAllCoreThreads 方法，来启动所有核心线程；
- 传入 true 给 allowCoreThreadTimeOut 方法，来让线程池在空闲的时候同样回收核心线程。

参考代码：[threadpooloom](threadpooloom)

### 务必确认清楚线程池本身是不是复用的

参考代码：[threadpoolreuse](threadpoolreuse)

### 需要仔细斟酌线程池的混用策略

要根据任务的“轻重缓急”来指定线程池的核心参数，包括线程数、回收策略和任务队列：

- 对于执行比较慢、数量不大的 IO 任务，或许要考虑更多的线程数，而不需要太大的队列。
- 而对于吞吐量较大的计算型任务，线程数量不宜过多，可以是 CPU 核数或核数 *2（理由是，线程一定调度到某个 CPU 进行执行，如果任务本身是
  CPU 绑定的任务，那么过多的线程只会增加线程切换的开销，并不能提升吞吐量），但可能需要较长的队列来做缓冲。
- 开启了 CallerRunsPolicy 拒绝处理策略，所以当线程满载队列也满的情况下，任务会在提交任务的线程，或者说调用 execute 方法的线程执行
    - 执行 IO 任务的线程池使用的是 CallerRunsPolicy 策略，如果直接使用这个线程池进行异步计算的话，当线程池饱和的时候，计算任务会在执行
      Web 请求的 Tomcat 线程执行，这时就会进一步影响到其他同步处理的线程，甚至造成整个应用程序崩溃

Java 8 的 parallel stream 功能，可以让我们很方便地并行处理集合中的元素，其背后是共享同一个 ForkJoinPool，默认并行度是 CPU
核数 -1。对于 CPU 绑定的任务来说，使用这样的配置比较合适，但如果集合操作涉及同步 IO 操作的话（比如数据库操作、外部服务调用等）就不太合适。

参考代码：[threadpoolmixuse](threadpoolmixuse)