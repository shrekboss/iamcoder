package org.coder.algorithm.programming;

import java.util.regex.Pattern;

/**
 * 我们需要注意以下几点：
 * <p>
 * 输入字符串仅包含数字、点和空格。
 * <p>
 * 空格只允许出现在数字和点之间，其他地方出现则非法。
 * <p>
 * IPv4地址由四个十进制数组成，每个数在0到255之间，由点分隔。
 * <p>
 * 我们需要将IPv4地址转换为32位整数。转换方法：将四个部分分别转换为二进制，然后拼接起来，再转换为十进制整数。
 * <p>
 * 步骤：
 * <p>
 * 去除空格？但要注意空格只能出现在数字和点之间，所以不能简单去除所有空格。我们需要验证空格的合法性。
 * <p>
 * 一种思路：先按照空格分割，但这样可能破坏结构。我们可以先检查空格的位置是否合法。
 * <p>
 * 更好的思路：先去掉所有空格，然后检查是否是一个合法的IPv4地址。但注意：去掉空格后，原来的数字和点之间的空格被去掉，如果空格出现在其他地方，去掉空格后可能变成合法的，但原字符串是非法的。所以不能先去掉空格。
 * <p>
 * 因此，我们需要先验证字符串的合法性：
 * 规则：
 * <p>
 * 只包含数字、点和空格。
 * <p>
 * 空格只能出现在数字和点之间，即空格的前后必须是数字和点（或者点和数字）。注意：空格不能出现在开头和结尾，也不能连续出现两个空格？实际上，空格在数字和点之间，那么空格可能出现多次，但每个空格都必须满足前后是数字和点（或点和数字）。
 * <p>
 * 我们可以用一个正则表达式来验证合法性，但比较复杂。我们可以分步骤：
 * <p>
 * 遍历字符串，检查每个字符是否合法（数字、点、空格）。
 * <p>
 * 检查空格的位置：如果当前字符是空格，那么它不能出现在开头和结尾，并且它的前一个字符和后一个字符必须是一个是数字，一个是点（或者点和数字，即数字和点的组合）。注意：数字和点之间可以有多个空格吗？题目没有明确，但根据描述，数字和点之间的空格是合法的，所以可以有一个或多个空格。但多个空格连续出现时，每个空格都要满足前后是数字和点。
 * <p>
 * 但是，这样检查比较复杂，而且容易漏掉情况。
 * <p>
 * 另一种思路：我们尝试按照点分割，但点之间可能有空格。所以，我们可以先按照点分割成四个部分，然后对每个部分处理，去掉空格，然后检查每个部分是否都是数字，并且在0-255之间。但是，这样分割的话，如果点之间有多余的空格，就会被分割到两个部分中，例如"192. 168.1.1"按照点分割会变成["192", " 168", "1", "1"]，我们可以去掉每个部分的前后空格。但是，如果空格出现在数字中间，比如"19 2.168.1.1"，那么按照点分割后，第一个部分"19 2"去掉空格后变成"192"，但原字符串中空格出现在数字中间，这是非法的吗？根据题目，数字和点之间的空格是合法的，那么数字之间的空格呢？注意：题目说“数字和点之间的空格是合法的”，所以数字之间的空格（即空格两边都是数字）是不合法的。所以我们需要在去掉空格之前检查每个部分是否含有空格，如果含有空格，说明空格出现在数字之间（因为我们已经按照点分割了，每个部分内部如果有空格，那空格两边都是数字），这是非法的。
 * <p>
 * 因此，步骤：
 * <p>
 * 用点分割字符串，如果分割后的数组长度不等于4，则非法。
 * <p>
 * 对每个部分，检查是否包含空格。如果包含空格，说明有空格在数字之间，非法。
 * <p>
 * 去掉每个部分的前后空格（因为空格在数字和点之间，那么数字前后可能有空格，这些空格是合法的，我们去掉后不影响数字的值）。
 * <p>
 * 检查每个部分是否都是数字，并且数值在0-255之间。
 * <p>
 * 如果都合法，则将四个部分转换为二进制，拼接成32位二进制字符串，然后转换为整数。
 * <p>
 * 但是，注意：原字符串中，点和数字之间的空格是合法的，但如果我们按照点分割，那么点之间的空格会被分割到两个部分中，例如"192. 168.1.1"分割后是["192", " 168", "1", "1"]，第二个部分前面有空格，我们去掉前后空格后是"168"，这是合法的。而如果空格出现在数字后面和点之间，例如"192 .168.1.1"，分割后是["192 ", "168", "1", "1"]，同样去掉空格后合法。
 * <p>
 * 但是，有一种情况：如果空格出现在点后面和数字之间，例如"192. 168.1.1"，我们已经处理了。如果空格出现在点前面和数字后面，例如"192 .168.1.1"，我们也处理了。
 * <p>
 * 那么，数字之间的空格，比如"19 2.168.1.1"，分割后第一个部分是"19 2"，包含空格，我们就判断非法。
 * <p>
 * 但是，还有一种情况：字符串开头或结尾有空格，按照点分割后，第一个部分和最后一个部分可能带有空格，我们去掉前后空格，所以开头和结尾的空格是合法的吗？题目说数字和点之间的空格是合法的，但开头和结尾的空格并不是数字和点之间，所以是非法的。我们的方法中，分割后第一个部分和最后一个部分去掉空格，但原字符串开头或结尾有空格，那么去掉空格后，我们无法判断原字符串是否有开头或结尾的空格。所以我们需要在分割之前检查开头和结尾是否有空格，如果有，则非法。
 * <p>
 * 因此，步骤修正：
 * <p>
 * 检查字符串是否以空格开头或结尾，如果是，则非法。
 * <p>
 * 用点分割字符串，如果分割后的数组长度不等于4，则非法。
 * <p>
 * 对每个部分，检查是否包含空格（即部分字符串内部有空格），如果有，则非法（因为空格只能在数字和点之间，但我们已经按点分割，部分内部不应该有空格，除非数字之间有空格）。
 * <p>
 * 去掉每个部分的前后空格（这时，因为内部没有空格，去掉前后空格后就是一个完整的数字字符串）。
 * <p>
 * 检查每个部分是否都是数字，并且数值在0-255之间。
 * <p>
 * 转换为32位整数。
 * <p>
 * 但是，注意：按点分割时，如果连续两个点，比如"192..168.1.1"，那么分割后会有空字符串，这显然是非法地址。
 * <p>
 * 另外，如果点之间没有数字，比如".168.1.1"，分割后第一个部分为空，去掉空格后还是空，非法。
 * <p>
 * 所以，我们的步骤应该能处理这些情况。
 * <p>
 * 代码实现：
 * <p>
 * 步骤：
 * <p>
 * 检查输入字符串是否为空，如果为空，非法。
 * <p>
 * 检查字符串是否以空格开头或结尾，如果是，非法。
 * <p>
 * 按照点分割字符串，得到四个部分。
 * <p>
 * 如果分割后的部分不是4个，非法。
 * <p>
 * 遍历每个部分：
 * a. 如果部分字符串包含空格（即部分内部有空格），非法。
 * b. 去掉部分字符串的前后空格，得到trimmedStr。
 * c. 检查trimmedStr是否为空，如果为空，非法。
 * d. 检查trimmedStr是否只包含数字，如果不是，非法。
 * e. 将trimmedStr转换为整数，检查是否在0到255之间，如果不是，非法。
 * <p>
 * 如果所有部分都合法，则将四个整数转换为二进制字符串（每个部分8位，不足8位前面补0），拼接起来，然后转换为整数。
 * <p>
 * 但是，注意：IPv4地址的每个部分可以是0，所以允许有前导零，比如"192.168.001.001"是合法的，转换为整数时，前导零不影响数值。
 * <p>
 * 因此，我们可以将每个部分转换为整数，然后计算32位整数。
 * <p>
 * 计算32位整数的方法：将四个整数分别左移相应的位数，然后相加。
 * 例如：ip = [a, b, c, d]，则整数 = (a << 24) + (b << 16) + (c << 8) + d
 * <p>
 * 这样就不需要显式地转换为二进制字符串。
 */
public class IPv4Converter {

    public static Long ipv4ToInt(String ipStr) {
        // 检查是否包含非法字符（只允许数字、点、空格）
        if (!Pattern.matches("[0-9. ]+", ipStr)) {
            return null; // 非法地址
        }

        // 检查空格位置是否合法
        // 空格只能出现在数字和点之间，即：
        // 1. 空格不能出现在开头或结尾
        // 2. 空格前后必须是数字和点（或点和数字）
        // 3. 不能有连续的空格（虽然题目没说，但实际中应该避免）
        if (ipStr.startsWith(" ") || ipStr.endsWith(" ")) {
            return null;
        }

        // 预处理：去除所有合法空格
        // 注意：这里我们只在确认空格位置合法的情况下才去除
        String processed = ipStr;

        // 检查空格是否合法并去除
        for (int i = 0; i < processed.length(); i++) {
            if (processed.charAt(i) == ' ') {
                // 检查空格前后字符
                if (i == 0 || i == processed.length() - 1) {
                    return null; // 空格在开头或结尾
                }

                char prev = processed.charAt(i - 1);
                char next = processed.charAt(i + 1);

                // 空格前是数字，后是点；或者前是点，后是数字
                boolean isValidSpace =
                        (Character.isDigit(prev) && next == '.') ||
                                (prev == '.' && Character.isDigit(next));

                if (!isValidSpace) {
                    return null; // 非法空格位置
                }
            }
        }

        // 去除所有空格
        processed = processed.replaceAll(" ", "");

        // 检查是否是合法的IPv4格式
        if (!isValidIPv4(processed)) {
            return null;
        }

        // 转换为32位整数
        return convertIPv4ToLong(processed);
    }

    private static boolean isValidIPv4(String ip) {
        String[] parts = ip.split("\\.");

        // 必须有4个部分
        if (parts.length != 4) {
            return false;
        }

        for (String part : parts) {
            // 检查每个部分是否为空
            if (part.isEmpty()) {
                return false;
            }

            // 检查是否只包含数字
            if (!part.matches("\\d+")) {
                return false;
            }

            // 检查是否有前导零（除了"0"本身）
            if (part.length() > 1 && part.startsWith("0")) {
                return false;
            }

            // 检查数值范围
            try {
                int num = Integer.parseInt(part);
                if (num < 0 || num > 255) {
                    return false;
                }
            } catch (NumberFormatException e) {
                return false; // 数字太大，超出int范围
            }
        }

        return true;
    }

    private static Long convertIPv4ToLong(String ip) {
        String[] parts = ip.split("\\.");
        long result = 0;

        for (int i = 0; i < 4; i++) {
            int num = Integer.parseInt(parts[i]);
            // 将每个部分左移相应的位数并相加
            result |= ((long) num << (24 - 8 * i));
        }

        // 为了确保是32位无符号整数，与0xFFFFFFFFL进行与运算
        return result & 0xFFFFFFFFL;
    }

    // 测试方法
    public static void main(String[] args) {
        // 测试用例
        String[] testCases = {
                "192.168.1.1",        // 正常地址
                "192 .168.1.1",       // 合法空格
                "192. 168.1.1",       // 合法空格
                "192.168 .1.1",       // 合法空格
                "192.168.1 .1",       // 合法空格
                "192 . 168 . 1 . 1",  // 合法空格
                " 192.168.1.1",       // 非法：开头空格
                "192.168.1.1 ",       // 非法：结尾空格
                "192.168.1",          // 非法：只有3部分
                "192.168.1.1.1",      // 非法：5部分
                "192.168.1.256",      // 非法：超出范围
                "192.168.01.1",       // 非法：前导零
                "192.a.1.1",          // 非法：包含字母
                "192.168.1  .1",      // 非法：连续空格（根据题目应为非法）
                "192 .168. 1.1"       // 合法：空格在数字和点之间
        };

        for (String testCase : testCases) {
            Long result = ipv4ToInt(testCase);
            System.out.printf("%-25s -> ", "\"" + testCase + "\"");
            if (result != null) {
                // 以无符号32位整数形式输出
                System.out.printf("0x%08X (%d)%n", result, result);
            } else {
                System.out.println("非法地址");
            }
        }
    }
}