## 性能计数器框架

### 代码重构优化

> 继承能解决代码重复的问题。可以将 ConsoleReporter 和 EmailReporter 中的相同代码逻辑，提取到父类 ScheduledReporter
> 中，以解决代码重复问题。

参考代码如下：

- [ScheduledReporter.java](ScheduledReporter.java)
- [EmailReporter.java](EmailReporter.java)

### 功能需求完善

最初的功能需求描述是下面这个样子的

> 设计开发一个小的框架，能够获取接口调用的各种统计信息，比如响应时间的最大值（max）、最小值（min）、平均值（avg）、百分位值（percentile），接口调用次数（count）、频率（tps）
> 等，并且支持将统计结果以各种显示格式（比如：JSON 格式、网页格式、自定义显示格式等）输出到各种终端（Console 命令行、HTTP
> 网页、Email、日志文件、自定义输出终端等），以方便查看。

经过整理拆解之后的需求列表如下所示：

> - 接口统计信息：包括接口响应时间的统计信息，以及接口调用次数的统计信息等。
> - 统计信息的类型：max、min、avg、percentile、count、tps 等。
> - 统计信息显示格式：JSON、HTML、自定义显示格式。
> - 统计信息显示终端：Console、Email、HTTP 网页、日志、自定义显示终端。

经过挖掘，还得到一些隐藏的需求，如下所示：

> - 统计触发方式：包括主动和被动两种。主动表示以一定的频率定时统计数据，并主动推送到显示终端，比如邮件推送。被动表示用户触发统计，比如用户在网页中选择要统计的时间区间，触发统计，并将结果显示给用户。
> - 统计时间区间：框架需要支持自定义统计时间区间，比如统计最近 10 分钟的某接口的 tps、访问次数，或者统计 12 月 11 日 00 点到
    12 月 12 日 00 点之间某接口响应时间的最大值、最小值、平均值等。
> - 统计时间间隔：对于主动触发统计，我们还要支持指定统计时间间隔，也就是多久触发一次统计显示。比如，每间隔 10s
    统计一次接口信息并显示到命令行中，每间隔 24 小时发送一封统计信息邮件。

版本 3 已经实现了大部分的功能，还有以下几个小的功能点没有实现。

> 被动触发统计的方式，也就是需求中提到的通过网页展示统计信息。实际上，这部分代码的实现也并不难。可以复用框架现在的代码，编写一些展示页面和提供获取统计数据的接口即可。
> 对于自定义显示终端，比如显示数据到自己开发的监控平台，这就有点类似通过网页来显示数据，不过更加简单些，只需要提供一些获取统计数据的接口，监控平台通过这些接口拉取数据来显示即可。
> 自定义显示格式。在框架现在的代码实现中，显示格式和显示终端（比如 Console、Email）是紧密耦合在一起的，比如，Console 只能通过
> JSON 格式来显示统计数据，Email 只能通过某种固定的 HTML
> 格式显示数据，这样的设计还不够灵活。可以将显示格式设计成独立的类，将显示终端和显示格式的代码分离，让显示终端支持配置不同的显示格式。

### 非功能需求完善

#### 易用性

参考代码：[PerfCounterTest.java](PerfCounterTest.java)

> 框架用起来还是稍微有些复杂的，需要组装各种类，比如需要创建 MetricsStorage 对象、Aggregator 对象、ConsoleViewer 对象，然后注入到
> ConsoleReporter 中，才能使用 ConsoleReporter。除此之外，还有可能存在误用的情况，比如把 EmailViewer 传递进了
> ConsoleReporter
> 中。总体上来讲，框架的使用方式暴露了太多细节给用户，过于灵活也带来了易用性的降低。
> 为了让框架用起来更加简单（能将组装的细节封装在框架中，不暴露给框架使用者），又不失灵活性（可以自由组装不同的 MetricsStorage
> 实现类、StatViewer 实现类到 ConsoleReporter 或 EmailReporter），也不降低代码的可测试性（通过依赖注入来组装类，方便在单元测试中
> mock），可以额外地提供一些封装了默认依赖的构造函数，让使用者自主选择使用哪种构造函数来构造对象。

参考代码：[MetricsCollector.java](MetricsCollector.java)

#### 性能

- 一个是采集和存储要异步来执行，因为存储基于外部存储（比如 Redis），会比较慢，异步存储可以降低对接口响应时间的影响。
- 另一个是当需要聚合统计的数据量比较大的时候，一次性加载太多的数据到内存，有可能会导致内存吃紧，甚至内存溢出，这样整个系统都会瘫痪掉。

- (解决)针对第一个问题，通过在 MetricsCollector 中引入 Google Guava EventBus 来解决。实际上，我们可以把 EventBus
  看作一个“生产者 - 消费者”模型或者“发布 - 订阅”模型，采集的数据先放入内存共享队列中，另一个线程读取共享队列中的数据，写入到外部存储（比如
  Redis）中。
- (未解决)针对第二个问题，将其划分为一些小的时间区间（比如 10
  分钟作为一个统计单元），针对每个小的时间区间分别进行统计，然后将统计得到的结果再进行聚合，得到最终整个时间区间的统计结果。不过，这个思路只适合响应时间的
  max、min、avg，及其接口请求 count、tps 的统计，对于响应时间的 percentile 的统计并不适用。
- (解决)对于 percentile 的统计要稍微复杂一些，分批从 Redis 中读取数据，然后存储到文件中，再根据响应时间从小到大利用外部排序算法来进行排序。排序完成之后，再从文件中读取第
  count*percentile（count 表示总的数据个数，percentile 就是百分比，99 百分位就是 0.99）个数据，就是对应的 percentile 响应时间。

#### 扩展性

> 框架的扩展性有别于代码的扩展性，是从使用者的角度来讲的，特指使用者可以在不修改框架源码，甚至不拿到框架源码的情况下，为框架扩展新的功能。比如
> MetricsStorage、StatViewer。举个例子来说，如果我们要让框架基于 HBase 来存储原始数据而非 Redis，那我们只需要设计一个实现
> MetricsStorage 接口的 HBaseMetricsStorage 类，传递给 MetricsCollector 和 ConsoleReporter、EmailReporter 类即可。

#### 容错性

> 在现在的框架设计与实现中，采集和存储是异步执行，即便 Redis 挂掉或者写入超时，也不会影响到接口的正常响应。除此之外，Redis
> 异常，可能会影响到数据统计显示（也就是 ConsoleReporter、EmailReporter 负责的工作），但并不会影响到接口的正常响应。

#### 通用性

> 除了接口统计这样一个需求，这个框架还可以适用到其他哪些场景中。比如是否还可以处理其他事件的统计信息，比如 SQL
> 请求时间的统计、业务统计（比如支付成功率）等。